import { createClient } from "@supabase/supabase-js"
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"
import { v4 as uuidv4 } from "uuid"
import { mintAndRegisterIP, isStoryConfigured, getSPGNftContract } from "@/lib/story-protocol"

export async function POST(req: NextRequest) {
  try {
    const formData = await req.formData()
    const files = formData.getAll("images") as File[]
    const trainingJobId = formData.get("trainingJobId") as string // Optional for storing individual images

    if (!files || files.length === 0) {
      return NextResponse.json({ error: "No images provided" }, { status: 400 })
    }

    // Validate all files are images
    const validImageTypes = ["image/jpeg", "image/png", "image/webp", "image/gif"]
    for (const file of files) {
      if (!validImageTypes.includes(file.type)) {
        return NextResponse.json(
          { error: `Invalid file type: ${file.type}. Only JPG, PNG, WEBP, and GIF are allowed.` },
          { status: 400 }
        )
      }
      if (file.size > 10 * 1024 * 1024) {
        // 10MB per image
        return NextResponse.json(
          { error: `Image ${file.name} is too large. Maximum size is 10MB per image.` },
          { status: 400 }
        )
      }
    }

    // Check minimum images requirement
    if (files.length < 5) {
      return NextResponse.json(
        { error: "At least 5 images are required for training." },
        { status: 400 }
      )
    }

    // Check total size
    const totalSize = files.reduce((sum, file) => sum + file.size, 0)
    if (totalSize > 500 * 1024 * 1024) {
      // 500MB total
      return NextResponse.json({ error: "Total images size exceeds 500MB limit." }, { status: 400 })
    }

    console.log(`üì¶ Creating zip from ${files.length} images...`)

    // Create Supabase admin client
    const supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_ROLE_KEY!,
      {
        auth: { autoRefreshToken: false, persistSession: false },
      }
    )

    // Store individual images in database and assets bucket if trainingJobId is provided
    const imageRecords: any[] = []
    if (trainingJobId) {
      console.log(
        `üíæ Storing ${files.length} individual images for training job ${trainingJobId}...`
      )

      for (let i = 0; i < files.length; i++) {
        const file = files[i]
        const arrayBuffer = await file.arrayBuffer()

        // Generate clean filename for storage
        const extension = file.name.split(".").pop()?.toLowerCase() || "jpg"
        const cleanName = file.name.replace(/[^a-zA-Z0-9.-]/g, "_")
        const timestamp = Date.now()
        const storageFileName = `${timestamp}_${i + 1}_${cleanName}`
        const storagePath = `training-images/${trainingJobId}/${storageFileName}`

        // Upload to assets bucket for individual image storage
        const { error: uploadError } = await supabase.storage
          .from("assets")
          .upload(storagePath, arrayBuffer, {
            contentType: file.type,
            upsert: false,
          })

        if (uploadError) {
          console.error(`Error uploading image ${file.name}:`, uploadError)
          // Continue with other images
        } else {
          // Get public URL
          const { data: urlData } = supabase.storage.from("assets").getPublicUrl(storagePath)

          // Record image in database
          const imageRecord = {
            training_job_id: trainingJobId,
            original_filename: file.name,
            file_size: file.size,
            content_type: file.type,
            supabase_storage_path: storagePath,
            supabase_public_url: urlData.publicUrl,
            display_order: i,
            story_registration_status: "pending",
          }

          imageRecords.push(imageRecord)
          console.log(`‚úÖ Stored individual image: ${file.name}`)
        }
      }

      // Bulk insert image records
      if (imageRecords.length > 0) {
        const { data: insertedRecords, error: dbError } = await supabase
          .from("training_images")
          .insert(imageRecords)
          .select()

        if (dbError) {
          console.error("Error inserting training images:", dbError)
        } else {
          console.log(`‚úÖ Inserted ${imageRecords.length} training image records`)

          // Check the training job's IP registration method
          const { data: trainingJob, error: jobError } = await supabase
            .from("training_jobs")
            .select("ip_registration_method")
            .eq("id", trainingJobId)
            .single()

          if (jobError) {
            console.error("Error fetching training job:", jobError)
          } else {
            const ipMethod = trainingJob?.ip_registration_method || "backend"

            if (ipMethod === "backend" && isStoryConfigured() && insertedRecords) {
              console.log("üìù Registering training images as IP assets with backend wallet...")

              // Process IP registrations in background (don't await to avoid blocking response)
              registerTrainingImagesAsIP(insertedRecords).catch((error: any) => {
                console.error("Error registering training images as IP:", error)
              })
            } else {
              console.log(`üìù Training images ready for ${ipMethod} IP registration`)
            }
          }
        }
      }
    }

    // Dynamically import JSZip
    const JSZip = (await import("jszip")).default as any
    const zip = new JSZip()

    // Add each image to the zip
    for (let i = 0; i < files.length; i++) {
      const file = files[i]
      const arrayBuffer = await file.arrayBuffer()

      // Generate a clean filename
      const extension = file.name.split(".").pop()?.toLowerCase() || "jpg"
      const cleanName = file.name.replace(/[^a-zA-Z0-9.-]/g, "_")
      const fileName = `image_${String(i + 1).padStart(3, "0")}_${cleanName}`

      zip.file(fileName, arrayBuffer)
    }

    // Generate the zip file
    const zipBuffer = await zip.generateAsync({ type: "arraybuffer" })
    const zipSizeMB = Math.round(zipBuffer.byteLength / 1024 / 1024)
    console.log(`üì¶ Generated zip file: ${zipSizeMB}MB`)

    // Generate unique filename for the zip
    const uniqueId = uuidv4()
    const zipFileName = `training-dataset-${uniqueId}.zip`
    const storagePath = `public/${zipFileName}`

    console.log(`üíæ Uploading zip to: models/${storagePath}`)

    // Upload zip to Supabase Storage
    const { error: uploadError, data: uploadData } = await supabase.storage
      .from("models")
      .upload(storagePath, zipBuffer, {
        contentType: "application/zip",
        upsert: false,
      })

    if (uploadError) {
      console.error("Error uploading zip:", uploadError)
      return NextResponse.json({ error: "Failed to upload zip file" }, { status: 500 })
    }

    // Get public URL
    const { data: urlData } = supabase.storage.from("models").getPublicUrl(storagePath)

    console.log(`‚úÖ Zip uploaded successfully: ${urlData.publicUrl}`)

    return NextResponse.json({
      success: true,
      publicUrl: urlData.publicUrl,
      storagePath: storagePath,
      fileName: zipFileName,
      originalFileCount: files.length,
      zipSizeMB: zipSizeMB,
    })
  } catch (error) {
    console.error("Zip creation error:", error)
    return NextResponse.json({ error: "Internal server error" }, { status: 500 })
  }
}

// Background function to register training images as IP assets using backend wallet
async function registerTrainingImagesAsIP(trainingImages: any[]) {
  const supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!,
    {
      auth: { autoRefreshToken: false, persistSession: false },
    }
  )

  try {
    const spgContract = getSPGNftContract()

    for (const image of trainingImages) {
      try {
        console.log(`üìù Registering IP for image: ${image.original_filename}`)

        // Create metadata for the training image
        const metadata = {
          title: `Training Image: ${image.original_filename}`,
          description: `Training image used for AI model development. Original filename: ${image.original_filename}`,
          ipType: "image" as const,
          attributes: [
            {
              trait_type: "File Type",
              value: image.content_type,
            },
            {
              trait_type: "File Size",
              value: `${Math.round(image.file_size / 1024)} KB`,
            },
            {
              trait_type: "Training Job ID",
              value: image.training_job_id,
            },
          ],
        }

        // Register as IP asset on Story Protocol using backend wallet
        const result = await mintAndRegisterIP({
          spgNftContract: spgContract,
          metadata,
        })

        if (result.success) {
          // Update database with Story Protocol information
          const { error: updateError } = await supabase
            .from("training_images")
            .update({
              story_ip_id: result.ipId,
              story_nft_contract: spgContract,
              story_token_id: result.tokenId?.toString(),
              story_tx_hash: result.txHash,
              story_registration_status: "registered",
            })
            .eq("id", image.id)

          if (updateError) {
            console.error(`Error updating image ${image.id} with Story data:`, updateError)
          } else {
            console.log(`‚úÖ Registered IP for image ${image.original_filename}: ${result.ipId}`)
          }
        } else {
          // Update status to failed
          await supabase
            .from("training_images")
            .update({
              story_registration_status: "failed",
            })
            .eq("id", image.id)

          console.error(
            `‚ùå Failed to register IP for image ${image.original_filename}:`,
            result.error
          )
        }
      } catch (error) {
        console.error(`Error processing image ${image.original_filename}:`, error)

        // Update status to failed
        await supabase
          .from("training_images")
          .update({
            story_registration_status: "failed",
          })
          .eq("id", image.id)
      }
    }
  } catch (error) {
    console.error("Error in registerTrainingImagesAsIP:", error)
  }
}
